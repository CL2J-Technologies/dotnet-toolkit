using System.Data;
using System.Data.Common;
using System.Text.Json;
using cl2j.Database.CommandBuilders;
using cl2j.Database.CommandBuilders.Models;
using cl2j.Database.Databases;
using cl2j.Database.Helpers;
using Microsoft.Extensions.Logging;

namespace cl2j.Database
{
    public static class ConnectionExtensions
    {
        public static ILogger? Logger { get; set; }
        public static DatabaseOptions DatabaseOptions { get; set; } = new();

        #region DDL

        public static async Task<bool> TableExists<T>(this DbConnection connection)
            => await TableExists(connection, typeof(T), CancellationToken.None);

        public static async Task<bool> TableExists(this DbConnection connection, Type type, CancellationToken cancellationToken, DbTransaction? transaction = null)
        {
            await EnsureConnectionOpen(connection, cancellationToken);

            var commandBuilder = CommandBuilderFactory.GetCommandBuilder(connection);
            var statement = commandBuilder.GetTableExistsStatement(type);

            try
            {
                var cmd = CreateExecuteCommand(connection, statement.Text, transaction);
                await cmd.ExecuteNonQueryAsync(cancellationToken);
                return true;
            }
            catch
            {
                return false;
            }
        }

        public static async Task CreateTable<T>(this DbConnection connection)
            => await CreateTable(connection, typeof(T), CancellationToken.None);

        public static async Task CreateTableIfRequired<T>(this DbConnection connection)
        {
            if (!await connection.TableExists<T>())
                await CreateTable(connection, typeof(T), CancellationToken.None);
        }

        public static async Task CreateTable(this DbConnection connection, Type type, CancellationToken cancellationToken, DbTransaction? transaction = null)
        {
            await EnsureConnectionOpen(connection, cancellationToken);

            var commandBuilder = CommandBuilderFactory.GetCommandBuilder(connection);
            var statement = commandBuilder.GetCreateTableStatement(type);
            Trace(statement.Text);

            var cmd = CreateExecuteCommand(connection, statement.Text, transaction);
            await cmd.ExecuteNonQueryAsync(cancellationToken);
        }


        public static async Task DropTableIfExists<T>(this DbConnection connection) => await DropTableIfExists(connection, typeof(T), CancellationToken.None);

        public static async Task DropTableIfExists(this DbConnection connection, Type type, CancellationToken cancellationToken, DbTransaction? transaction = null)
        {
            await EnsureConnectionOpen(connection, cancellationToken);

            var commandBuilder = CommandBuilderFactory.GetCommandBuilder(connection);
            var statement = commandBuilder.GetDropTableIfExistsStatement(type);
            Trace(statement.Text);

            try
            {
                var cmd = CreateExecuteCommand(connection, statement.Text, transaction);
                await cmd.ExecuteNonQueryAsync(cancellationToken);
            }
            catch
            {
            }
        }

        #endregion DDL

        #region Commands

        public static async Task Insert<TIn>(this DbConnection connection, TIn item)
            => await Insert(connection, item, CancellationToken.None);

        public static async Task<TOut?> Insert<TIn, TOut>(this DbConnection connection, TIn item)
        {
            var result = await Insert(connection, item, CancellationToken.None);
            if (result is null)
                return default;
            return (TOut)result;
        }

        public static async Task<object?> Insert<TIn>(this DbConnection connection, TIn item, CancellationToken cancellationToken, DbTransaction? transaction = null)
        {
            await EnsureConnectionOpen(connection, cancellationToken);

            var commandBuilder = CommandBuilderFactory.GetCommandBuilder(connection);
            var statement = commandBuilder.GetInsertStatement(typeof(TIn));

            //Generate key value that requires auto-generation
            foreach (var key in statement.TableDescriptor.Keys)
            {
                if (key.ColumnAtribute.Key == DataAnnotations.KeyType.AutoGeneratedKey)
                    key.Property.SetValue(item, Guid.NewGuid().ToString());
            }

            var cmd = CreateExecuteCommand(connection, statement.Text, transaction);
            cmd.CreateParameters(item, statement.TableDescriptor);
            var result = await cmd.ExecuteScalarAsync(cancellationToken);

            Trace($"{statement.Text} --> '{result}'");

            return result;
        }

        #endregion Commands

        #region Query

        public static async Task<List<T>> Query<T>(this DbConnection connection)
            => await Query<T>(connection, CancellationToken.None);

        public static async Task<List<T>> Query<T>(this DbConnection connection, CancellationToken cancellationToken, DbTransaction? transaction = null)
        {
            var commandBuilder = CommandBuilderFactory.GetCommandBuilder(connection);
            var statement = commandBuilder.GetQueryStatement(typeof(T));
            return await Query<T>(connection, statement.Text, cancellationToken, transaction);
        }

        public static async Task<List<T>> Query<T>(this DbConnection connection, string sql)
            => await Query<T>(connection, sql, CancellationToken.None);

        public static async Task<List<T>> Query<T>(this DbConnection connection, string sql, CancellationToken cancellationToken, DbTransaction? transaction = null)
        {
            await EnsureConnectionOpen(connection, cancellationToken);

            var commandBuilder = CommandBuilderFactory.GetCommandBuilder(connection);
            var tableDescriptor = commandBuilder.GetTableDescriptor(typeof(T));

            var cmd = CreateExecuteCommand(connection, sql, transaction);
            var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SingleResult | CommandBehavior.SequentialAccess, cancellationToken);

            var results = await reader.Read<T>(tableDescriptor);
            return results;
        }

        public static async Task<T?> QuerySingle<T>(this DbConnection connection, string sql)
            => await QuerySingle<T>(connection, sql, CancellationToken.None);

        public static async Task<T?> QuerySingle<T>(this DbConnection connection, string sql, CancellationToken cancellationToken, DbTransaction? transaction = null)
        {
            await EnsureConnectionOpen(connection, cancellationToken);

            var commandBuilder = CommandBuilderFactory.GetCommandBuilder(connection);
            var tableDescriptor = commandBuilder.GetTableDescriptor(typeof(T));

            var cmd = CreateExecuteCommand(connection, sql, transaction);
            var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SingleResult | CommandBehavior.SingleRow | CommandBehavior.SequentialAccess, cancellationToken);

            return await reader.ReadSingle<T>(tableDescriptor);
        }

        #endregion

        #region Private

        private static async Task EnsureConnectionOpen(DbConnection connection, CancellationToken cancellationToken)
        {
            if (connection.State != ConnectionState.Open)
                await connection.OpenAsync(cancellationToken);
        }

        private static DbCommand CreateExecuteCommand(DbConnection connection, string sql, DbTransaction? transaction)
        {
            var cmd = connection.CreateCommand();
            cmd.Transaction = transaction;
            cmd.CommandText = sql;
            cmd.CommandType = CommandType.Text;
            return cmd;
        }

        private static void CreateParameters<T>(this DbCommand command, T t, TableDescriptor tableDescriptor)
        {
            foreach (var column in tableDescriptor.Columns)
            {
                var value = column.Property.GetValue(t, null);

                if (column.ColumnAtribute.Json)
                    value = JsonSerializer.Serialize(value);
                else if (column.Property.PropertyType == Types.TypeDateTimeOffset && string.IsNullOrEmpty(column.ColumnAtribute.Default))
                    value = DateTimeOffset.UtcNow;

                var parameter = command.CreateParameter();
                parameter.ParameterName = column.Name;
                parameter.Value = value ?? DBNull.Value;
                command.Parameters.Add(parameter);
            }
        }

        private static void Trace(string text) => Logger?.Log(DatabaseOptions.TraceLevel, text);

        #endregion
    }
}
